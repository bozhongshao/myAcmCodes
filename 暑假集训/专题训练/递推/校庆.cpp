#include<iostream>
using namespace std;

int main()
{
	__int64 a[1001];
	int n,i;
	a[1]=2;
	while(cin>>n)
	{
	   for(i=2;i<=n;i++)
	   {
		   a[i]=a[i-1]+(i-1)*i/2+1;
	   }
	   cout<<a[n]<<endl;
	}
	return 0;
}/*
 这显然是问5个平面能将一个空间分多少分。 

实际上 
这过程是一个3阶等差数列的通项公式的推导 
1阶等差数列： 1，2，3，4，5，6... 点分直线问题 
2阶等差数列： 1，2，4，7，11，16... 直线分面问题 
3阶等差数列：1，2，4，8，15，26... 面分空间问题 
请注意，我这样排是有意思的： 
将2阶等差数列相邻两项相减可得到1阶等差数列... 
将3阶等差数列相邻两项相减可得到2阶等差数列... 

如果再往下讨论，就超出了常人的思考能力范围... 
然后，我是常人~~~ 
最多给你他的通项公式的推导方法： 
3阶等差数列的通项公式符合 
f（x）=a x^3 + b x^2+ c x + d 
分别回代四组数据 
a+b+c+d=2 
8a+4b+2c+d=4 
27a+9b+3c+d=8 
64a+16b+4c+d=15 
算吧~~~~ 

ps:其实 维的类比法 是对的，不过他好像理解错了一部分“依此类推......增加了8个部分”这一段是错的。为什么呢？是因为他“依此类推"推错了......


 */