#include<iostream>
using namespace std;

int main()
{
	int t,n,result,i,num;
	cin>>t;
	while(t--)
	{
		cin>>n;
		if (n>0) cin>>result;
	for(i=2;i<=n;i++)
	{
		cin>>num;
		result^=num;
	}
	if (result) cout<<"1"<<endl;
	else cout<<"0"<<endl;
	}
	return 0;
}
/*从如上性质可知，两个人如果都采用正确操作，那么面对非奇异局势，先拿者必胜；反之，则后拿者取胜。

    那么任给一个局势（a，b），怎样判断它是不是奇异局势呢？我们有如下公式：
    ak =[k（1+√5）/2]，bk= ak + k （k=0，1，2，...,n 方括号表示取整函数)
奇妙的是其中出现了黄金分割数（1+√5）/2 = 1。618...,因此,由ak，bk组成的矩形近似为黄金矩形，由于2/（1+√5）=（√5-1）/2，可以先求出j=[a（√5-1）/2]，若a =[j（1+√5）/2]，那么a = aj，bj = aj + j，若不等于，那么a = aj+1，bj+1 = aj+1+ j + 1，若都不是，那么就不是奇异局势。然后再按照上述法则进行，一定会遇到奇异局势。

（三）尼姆博奕（Nimm Game）：有三堆各若干个物品，两个人轮流从某一堆取任意多的物品，规定每次至少取一个，多者不限，最后取光者得胜。

    这种情况最有意思，它与二进制有密切关系，我们用（a，b，c）表示某种局势，首先（0，0，0）显然是奇异局势，无论谁面对奇异局势，都必然失败。第二 种奇异局势是（0，n，n），只要与对手拿走一样多的物品，最后都将导致（0，0，0）。仔细分析一下，（1，2，3）也是奇异局势，无论对手如何拿，接 下来都可以变为（0，n，n）的情形。

    计算机算法里面有一种叫做按位模2加，也叫做异或的运算，我们用符号（+）表示这种运算。这种运算和一般加法不同的一点是1+1=0。先看（1，2，3）的按位模2加的结果：

1 =二进制01
2 =二进制10
3 =二进制11 （+）
―――――――
0 =二进制00 （注意不进位）

    对于奇异局势（0，n，n）也一样，结果也是0。

    任何奇异局势（a，b，c）都有a（+）b（+）c =0。*/

